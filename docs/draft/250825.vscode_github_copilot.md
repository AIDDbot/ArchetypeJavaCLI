
# VSCode and GitHub Copilot

> Setup and usage of the GitHub AI agent

**GitHub Copilot** has become the most popular AI assistant for programmers. And it's no coincidence: its integration with **Visual Studio Code** is so smooth that sometimes you forget you're working with an AI.

But do you really know how to **configure it** to help you in the most efficient way? Do you know all the options you have to customize its behavior?

In this article, we'll see how to **make the most** of GitHub Copilot's capabilities in VSCode, from basic setup to advanced **prompt and context engineering** techniques.

## Basic Copilot Settings

First things first. Before you start using GitHub Copilot, you need to have everything **properly configured**.

In VSCode `Settings`, search for "GitHub Copilot" and you'll see several options:

My recommendation: **enable everything** and then adjust according to your preferences.

```json
{
  "chat.agent.maxRequests": 100,
  "chat.tools.autoApprove": true,
  "github.copilot.advanced": {
    "inlineSuggest": true,
    "inlineSuggest.enable": true,
    "inlineSuggest.showSuggestionsAlways": true
  },
  "github.copilot.chat.codesearch.enabled": true,
  "github.copilot.chat.agent.thinkingTool": true,
  "github.copilot.chat.languageContext.[your-language].enabled": true,
  "github.copilot.enable": {
    "*": true,
    "inlineSuggest": true,
    "inlineSuggest.enable": true,
    "inlineSuggest.showSuggestionsAlways": true
  },
  "github.copilot.nextEditSuggestions.enabled": true,
}
```

## Instructions

This is where **GitHub Copilot** stands out from other assistants. It lets you set up **custom instructions** that guide its behavior.

Instructions are written in Markdown format in `.md` files inside the `.github` folder at your project's root.

GitHub Copilot handles instructions **hierarchically** at different levels: organization, user, or project. This can be confusing. Let's ignore organization-level instructions for now, since they require special licenses and are only active in GitHub organizations.

That leaves two: User-level (valid for all your projects) and repository-level (valid for a specific project). Let's start with repository-level, which is the most useful.

### Repository Instructions

Create a Markdown file `.github/copilot-instructions.md` at your project's root. Pay attention to the folder name: `.github` with a leading dot. Whatever you write in this file will be included in every Copilot request, so keep it concise and general. For example, add:

- Your **experience level** as a programmer
- **Preferred languages** and frameworks
- **Code style** you prefer
- **Design patterns** you use
- **Preferred response language**
- **Output format** you need

When starting out, a short paragraph grouping these preferences is enough. Remember, it gets added to every request.

Here's an example of what an instructions file might contain (don't take it literally, it's just an idea; for something more professional, see [AIDDbot copilot instructions](https://github.com/AIDDbot/AIDDbot/blob/main/.github/copilot-instructions.md)):

```markdown
# Instructions for [Project Name]

- Use strict TypeScript
- You are on a Windows 11 system
- Use the git bash terminal for all console commands
- If unavailable, use the Windows command prompt
- Write code and documentation in English, but speak to the user in their language
- Follow the Repository pattern for data access
- Implement unit tests for all functions
- Document APIs with JSDoc
- Use ESLint and Prettier for formatting
- Avoid using `any`, use specific types
- Implement error handling with try-catch
- Use constants for magic values
```

**Practical tip**: keep repository instructions short, precise, and action-oriented. Avoid ambiguous instructions or those that depend on external resources Copilot can't access.

### Context Instructions

GitHub Copilot can also use instructions specific to each context. For example, if you're working on an Angular project, or you like to use a certain ORM in Java.

These instructions are stored in the `.github/instructions` folder at your project's root, in files named `[context].instructions.md` with a front-matter header indicating purpose and applicable files.

For example, you might have an instructions file for Node 24 called `.github/instructions/node24.instructions.md`:

````markdown
---
description: "Node 24 Framework Best Practices"
applyTo: "**/*.ts"
---
# Node 24 Framework Best Practices

## ðŸš« AVOID These Dependencies

**Never install these when using modern Node.js:**

- _ts-node_ - Not needed with native TypeScript support
- _nodemon_ - Use `node --watch` instead
- _jest_ or any other testing library (Use native `node --test` instead)
- _axios_ or any HTTP client library (use native `node:http` or `node:https`)
- Any TypeScript compilation loaders

## Import Instructions

- Use the `.ts` suffix for TypeScript files.
- Use `type` for type imports.

````

This content would be added as context whenever Copilot is working with TypeScript files.

> Note: These files can also be saved in your local user profile folder, making them apply to all projects. But it's easier and more practical to make them custom for each repository and copy them manually from somewhere accessible.

To get an idea of their potential, check out these GitHub repositories:
- [GitHub Awesome Copilot instructions](https://github.com/github/awesome-copilot/tree/main/instructions)
- [AIDDbot instructions](https://github.com/AIDDbot/AIDDbot/tree/main/.github/instructions)

### Manual Invocation of Instructions

Not everything is **automatic suggestions** based on the `applyTo` glob in instruction files. GitHub Copilot also lets you invoke instruction files inside a prompt so they're taken into account. Sometimes they're used as templates to generate documentation or just specific context for a particular request.

```markdown
Create an application structure document following the instructions #file:instructions/project-structure.instructions.md and confirm the result in git according to the instructions #file:git-commit.instructions.md
```

This way, it's explicit which instructions to follow. And yes, you can also simply add the instruction file(s) to the chat context, but then it only applies at that moment and isn't easy to reuse; that's exactly what we'll see next.

## Prompt Library

There are certain types of requests we make over and over. So much so, that Copilot includes a series of predefined prompts that are invoked like commands. They follow a naming convention that identifies them. These are the **slash-commands**.

### Comandos Slash

[Slash commands](https://docs.github.com/en/copilot/reference/cheat-sheet#slash-commands) are predefined shortcuts that execute specific actions:

**Basic management commands:**
- `/clear`: Starts a new chat session
- `/help`: Quick reference and basic concepts of GitHub Copilot

**Analysis and explanation commands:**
- `/explain`: Explains the selected code
- `/fix`: Fixes problems in the code

**Generation commands:**
- `/tests`: Generates tests for the code
- `/new`: Creates a new project
- `/fixTestFailure`: Finds and fixes a failing test

To use a slash command, type `/` in the chat prompt box, followed by the command name. The list of available commands may vary and can be extended with your own commands.

### Custom Commands

Copilot lets you create [custom commands](https://code.visualstudio.com/docs/copilot/copilot-customization#_prompt-files-experimental) using prompt files similar to repository instructions.

The difference is that they're stored in the `.github/prompts` folder and their name must be `[command].prompt.md`. And, like instructions, they start with a front-matter header.

Example of a `/refactor` command in the file `.github/prompts/refactor.prompt.md`:

```markdown
---
description: "Code Refactoring"
---
# Code Refactoring

Refactor the selected code following these principles:
- Extract small, single-responsibility functions
- Use descriptive names for variables and functions
- Eliminate duplicate code
- Maintain original functionality
- Follow the instructions in #file:clean-code.instructions.md
- When finished, commit by running the [/U_git-commit](.github/prompts/U_git-commit.prompt.md) command
```

As you can see, **prompt files** can reference other project files using standard Markdown syntax or the specific syntax `#file:folder/file-name.extension`. This lets you provide extra context like API specs or product documentation.

Here's a summary of some [chat variables](https://docs.github.com/en/copilot/reference/cheat-sheet#chat-variables) you can use, both in prompts saved in files and in the prompt you type in the chat:

**Chat variables** enrich any mode:
- `#file`: Includes the content of the specified file
- `#selection`: Includes the currently selected text
- `#function`: Includes the current function or method

**Chat participants** act as specialized experts:
- `@workspace`: Considers your project's entire structure
- `@vscode`: Specific help with Visual Studio Code
- `@terminal`: Assistance with terminal commands
- `@github`: GitHub-specific skills

Again, here are a couple of example repositories to see what's possible:

- [AIDDbot command prompts](https://github.com/AIDDbot/AIDDbot/tree/main/.github/prompts)
- [GitHub Awesome Copilot command prompts](https://github.com/github/awesome-copilot/tree/main/prompts)

One last note about the difference between instructions and prompts. Custom commands are always voluntary, they're not activated by context, so they don't have `applyTo`. Instead, they let you configure the model, tools, and even the chat mode.

Don't know what chat modes are? Keep reading.

## Chat Modes

VSCode offers different **chat modes** tailored to various development needs. Each mode optimizes the experience for specific types of tasks. By default, there are three: Ask, Edit, and Agent.

### Ask Mode
For **quick questions** and queries. It's the most direct and conversational. Ideal for understanding code or learning about a specific usage.

### Edit Mode
Specialized in **modifying code**. Lets you select code and request specific changes. Perfect for quick fixes, explanations of specific functions, or improvement suggestions within a file.

### Agent Mode
The most powerful. Acts as a **development assistant** that can:
- Analyze your entire workspace
- Create, modify, and delete files and folders
- Execute multiple tasks in sequence
- Run commands
- Use MCP tools

This mode is especially useful for assigning Copilot real and complex tasks. In other words, this is the default mode you'll use daily... until you see how to create your own.

### Custom Chat Modes

Yes, you can create new custom chat modes for your needs. It's similar to creating instructions and custom commands. To do this, create a `*.chatmode.md` file in the `.github/chatmodes` folder at your project's root.

The front-matter structure is the same as for commands, but its use is more like instructions. Let me explain. Once selected, the chat mode adds its content to every prompt. It's like an extension of the general instructions file. Or like instructions with glob `*.*`, but without needing to specify it.

Example of a custom `revisor` chat mode in the file `.github/chatmodes/revisor.chatmode.md`:

```markdown
---
description: "I am a code reviewer"
---

# I am a code reviewer

- I cannot change code
- I cannot add features
- I will follow the instructions in #file:clean-code.instructions.md
- I will only report bugs and recommendations
- It will be a prioritized list for you to copy and paste into the chat
```

To use it, simply select the `revisor` chat mode in Copilot chat and make a request like this:

```text
Review the class #file:my-class.ts
```

Again, the most interesting examples can be found in these GitHub repositories:
- [AIDDbot chat mode](https://github.com/AIDDbot/AIDDbot/tree/main/.github/chatmodes)
- [GitHub Awesome Copilot chatmodes](https://github.com/github/awesome-copilot/tree/main/chatmodes)

The potential of these modes increases when you assign them a set of tools they can use. Tools? What tools? Keep reading, you're almost ready to master everything you can do with GitHub Copilot.

## Tools and MCP

GitHub Copilot can be **extended** with external tools using the [MCP (Model Context Protocol)](https://docs.github.com/en/copilot/how-tos/provide-context/use-mcp/extend-copilot-chat-with-mcp).

### What is MCP?

The [MCP protocol](https://docs.github.com/en/copilot/concepts/about-mcp) allows AI models to **interact with external tools in natural language**. Among other things, you can request actions like:

- Run terminal commands
- Connect to external APIs
- Access databases
- Use specific development tools
- Consult API documentation
- Validate code against business rules
- Integrate with CI/CD tools

For example, if you install the GitHub MCP, you could ask for things like:
- `Create a repository in my GitHub account called "my-mega-project"`
- `Give me the list of repositories in the organization "my-company"`
- `Give me the list of issues in the repository "my-repo"`
- `Create an issue in the repository "my-repo" with the title "my-issue"`

All, as you see, in natural language and using the tool intelligently. But you can also specify the tool you want to use with a prompt.

```markdown
- Create a repository in my GitHub account called "my-mega-project" using #GitHubIssues
```

### MCP Setup

First, understand a couple of basic concepts. As mentioned, MCP is a [protocol created by Anthropic](https://modelcontextprotocol.io/docs/getting-started/intro) so AI models can use external tools. Implementation is done through MCP servers, which you need to install and configure. Once done, they must be started before use. Remember, they're background services. Once running, they'll offer a list of tools, and those tools are what LLMs will use.

The easiest way to install an MCP server is to use the [MCP tools marketplace](https://code.visualstudio.com/mcp).

This generates a configuration file in the `.vscode/mcp.json` folder that you can edit to configure the tools you want to use.

Example configuration to use the GitHub MCP:
```json
{
  "servers": {
    "github": {
      "type": "http",
      "url": "https://api.githubcopilot.com/mcp/"
    }
  }
}
```

Usually, you'll need a credentials and permissions process depending on the service you use. It may require an API key or OAuth token.

### Tool Sets

After installing and launching a few MCP servers, you'll see the number of available tools is huge. Copilot detects this and warns you if you're using too many (this affects its context memory).

The idea is to activate them as needed. You can do this from the chat interface or in the front-matter of prompt and chat mode files. In any case, it's tedious to select certain tools over and over. Trust me, you'll have way more tools to use than you imagine.

Fortunately, there's the concept of [tool sets](https://code.visualstudio.com/docs/copilot/chat/mcp-servers#_group-related-tools-in-a-tool-set) that lets you group tools into logical units, give them a name, and activate them all at once.

Some servers, after installation, offer their own commands that already include their tools. This is a constantly expanding world.

### Advanced Use Cases

The MCP protocol lets you wrap any service or even terminal utilities so they're offered to MCP clients (Copilot is an MCP client) to be invoked in natural language.

For example, you can create an MCP server for your own service or terminal utility. Then use it in Copilot or from a chat with an LLM. I wouldn't be surprised if MCP server generation becomes a standard feature of the apps we build from now on.

Remember, the goal is to handle any software using natural language instructions, which agents then translate into API calls, CLI commands, or user actions.

## Conclusion

**GitHub Copilot** in VSCode is much more than smart auto-complete. It's a **complete ecosystem** for AI-assisted development that you can customize down to the last detail.

The key is **gradual progression**: start with basic setup and personal instructions, get familiar with slash commands and chat variables, experiment with custom prompts, and finally explore MCP possibilities when your needs require it.

- **Setup**: Adjust auto-complete and chat behavior.
- **Instructions**: Detail the use of libraries, languages, documentation, etc.
- **Prompts**: Create a library of reusable prompts.
- **Chat modes**: Use custom chat modes for specific situations or cases.
- **Tools**: Install MCP servers and use their tools.

The **time investment** pays off quickly. An agent that understands your specific project, your code preferences, and has access to the tools you use daily becomes **the development partner** you really need: one that not only suggests, but _understands and contributes_ meaningfully to your work.

I suggest you take a look at [AIDDbot](https://github.com/AIDDbot/AIDDbot) for inspiration. It's a project that uses GitHub Copilot to generate code, documentation, tests, etc. following the [AI-Driven Development](https://aicode.academy/blog/es/aiddbot-workflow/) methodology.

And if you want help for your team, I offer a [training course where I teach you to use GitHub Copilot](https://aicode.academy/cursos/vs-code-copilot/) professionally.